# Tendril Annotation Processor
This library contains key features and capabilities for the explicit purpose of facilitating and simplifying the creation of dedicated annotation processors. As such, this does not do any annotation processing as such, but rather provides the means to enable another to do so as easily with the least amount of effort as possible. At the core of this is the `AbstractTendrilProcessor` which does the initial leg-work of iterating through the classes/methods which have been detected during the round as having the desired annotation, converting them to a convenient `tendril-codegen` representations and passing them to the appropriate *process* method (namely `processType()` for classes and equivalents, and `processMethod()` for methods). It is these *process* methods which must be overridden by a concrete processor, and where the processing of the detected elements is to be performed. The elements which are being processed are not themselves passed, but rather stored in `protected` instance fields which can be accessed by the concrete processed. Namely:
* `currentClassType` - the `ClassType` of the class being processed (or which contains the method being processed)
* `currentClass` - `JClass` representation of the class being processed (of which contains the method being processed)
* `currentMethod` - `JMethod` representation of the method being processed (`null` if it is a class being processed rather than a method)
It is then up to the concrete processor to do what needs to be done, based on this information provided.

There are additional processors available, for some more niche situations that may arise. These extend `AbstractTendrilProcessor` and can in turn be further extended to leverage the specific features and capabilities that they provide (unless otherwise noted).

## AbstractDelayedAnnotationTendrilProcessor
In situations where annotations are applied to a element being processed, which themselves are generated, results in a problem where processing the element cannot be completed until the generated annotation is first generated. Here the processor is not looking for the annotation in question, but still requires it for understanding the class the processor is acting upon and thus to perform the processing. An example of this would be `@BeanIdEnum` and the resulting `<Enum>Id` annotation. Processing of any Bean which either uses this `qualifier` (either on the Bean itself or any dependency) cannot complete until the `<Enum>Id` annotation is first generated.
This is where the `AbstractDelayedAnnotationTendrilProcessor` comes into play, if the conversion to `JClass` in `AbstractTendrilProcessor` fails due to a missing annotation, processing is delayed until the missing annotation becomes available. It relies on an `AbstractLoaderProcessor` existing for the missing annotation to notify when it is generated. From the perspective of the client code, no additional logic or equalent is necessary. Simply choosing `AbstractDelayedAnnotationTendrilProcessor` in lieu of `AbstractTendrilProcessor` provides this capability.

## AbstractGeneratedAnnotationTendrilProcessor
While `AbstractDelayedAnnotationTendrilProcessor` processes a (guaranteed) pre-existing annotation, but the class or method in question may encounter an annotation which is generated, `AbstractGeneratedAnnotationTendrilProcessor` is for situations where processing is to take place on an annotation which is generated. Using the `@BeanIdEnum` as an example, this processor would allow for having processing trigger on the `<Enum>Id` annotation itself. In this situation the processing must also be delayed until the desired annotation is generated, however the annotation processor will not even trigger the until the round **after** the annotation is generated. This means that if the annotation is generated in round 1, only items which are detected during round 2 will be triggered for processing. This is what the `AbstractGeneratedAnnotationTendrilProcessor` aims to address. Knowing that elements in previous rounds will be missed, it leverages the `EnvironmentCollector` to "rerun" all previous round to ensure that **all** elements (regardless of when they would have been detectable) are processed. To leverage this capability, simply extend `AbstractGeneratedAnnotationTendrilProcessor` in lieu of `AbstractTendrilProcessor`, no additional changes required.

## AnnotationLoaderProcessor
Unlike the other processors, this is not designed to generate anything, but rather act as a notifier when an annotation with a given annotation is detected. The goal is to notify when an annotation is generated, provided the annotation in question has an annotation applied to it. This is designed to work in conjunction with `AbstractDelayedAnnotationTendrilProcessor` to trigger any delayed processing resulting from a missing annotation. For example, the `<Enum>Id` annotations generated from `@BeanIdEnum` annotated `Enums` have an `@EnumQualifier` annotation applied. Thus, `tendril-di` has an `AnnotationLoaderProcessor` which looks for `@EnumQualifier` and notifies whenever it detects one. Client loaders do not need to do anything more than just simply extend `AnnotationLoaderProcessor` and configuring themselves to look for the annotation which is applied to the generated annotation (i.e.: `@EnumQualifier` per the example). Loaders are not expected to perform any actual processing.

## EnvironmentCollector
This is the only processor which is directly provided by the `tendril-annotation-processor` library, however it is not a processor per-say. It does no processing other than to track all elements which were detected for each round (or more accurately it listens for all annotations and save the `RoundEnvironment` for each round). This allows it to act as a repository of all processable elements, and can be leveraged by other processors (such as `AbstractGeneratedAnnotationTendrilProcessor`) to "rerun" processing on previous rounds, if previous round would have been skipped for some reason. This is not intended to be overridden in the client annotation processor, however it can be leveraged if/when needed by calling `EnvironmentCollector.getAllEnvironments()`.
