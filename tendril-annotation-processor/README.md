# Tendril Annotation Processor
This library contains key features and capabilities for the explicit purpose of facilitating and simplifying the creation of dedicated annotation processors. As such, this does not do any annotation processing as such, but rather provides the means to enable another to do so as easily with the least amount of effort as possible. At the core of this is the `AbstractTendrilProcessor` which does the initial leg-work of iterating through the classes/methods which have been detected during the round as having the desired annotation, converting them to a convenient `tendril-codegen` representations and passing them to the appropriate *process* method (namely `processType()` for classes and equivalents, and `processMethod()` for methods). It is these *process* methods which must be overridden by a concrete processor, and where the processing of the detected elements is to be performed. The elements which are being processed are not themselves passed, but rather stored in `protected` instance fields which can be accessed by the concrete processed. Namely:
* `currentClassType` - the `ClassType` of the class being processed (or which contains the method being processed)
* `currentClass` - `JClass` representation of the class being processed (of which contains the method being processed)
* `currentMethod` - `JMethod` representation of the method being processed (`null` if it is a class being processed rather than a method)
It is then up to the concrete processor to do what needs to be done, based on this information provided.

There are additional processors available, for some more niche situations that may arise. These extend `AbstractTendrilProcessor` and can in turn be further extended to leverage the specific features and capabilities that they provide (unless otherwise noted).

## AbstractDelayedAnnotationTendrilProcessor
In situations where annotations are applied to a element being processed, which themselves are generated, results in a problem where processing the element cannot be completed until the generated annotation is first generated. Here the processor is not looking for the annotation in question, but still requires it for understanding the class the processor is acting upon and thus to perform the processing. An example of this would be `@BeanIdEnum` and the resulting `<Enum>Id` annotation. Processing of any Bean which either uses this `qualifier` (either on the Bean itself or any dependency) cannot complete until the `<Enum>Id` annotation is first generated.
This is where the `AbstractDelayedAnnotationTendrilProcessor` comes into play, if the conversion to `JClass` in `AbstractTendrilProcessor` fails due to a missing annotation, processing is delayed until the missing annotation becomes available. It relies on an `AbstractLoaderProcessor` existing for the missing annotation to notify when it is generated. From the perspective of the client code, no additional logic or equalent is necessary. Simply choosing `AbstractDelayedAnnotationTendrilProcessor` in lieu of `AbstractTendrilProcessor` provides this capability.

## AbstractGeneratedAnnotationTendrilProcessor
While `AbstractDelayedAnnotationTendrilProcessor` processes a (guaranteed) pre-existing annotation, but the class or method in question may encounter an annotation which is generated, `AbstractGeneratedAnnotationTendrilProcessor` is for situations where processing is to take place on an annotation which is generated. For this to work a tagging annotation must be applied to the generated annotation which is defined in the code base and the custom processor assigned to process that tagging annotation. This tagging annotation should not be used for any other purpose other than to serve as this tag. Thus as the tagging annotation is detected, the through this the generated annotation will be found, and the search will be repeated across all prior annotation processing rounds to find any references of this generated annotation. The `AbstractGeneratedAnnotationTendrilProcessor` will handle this extra layer of processing, allowing the processor which extends it to focus purely on processing the elements against which the generated annotation was applied. See `@Blueprint` for an example of this in action.

Note that there are some limitations when this is employed, specifically the generated annotation will be processed only once - the first time it is found. So applying the generated annotation to another generated element runs the risk of the generated element not being found when processing the generated annotation. This should be fine if the generated element is generated during the same round of processing as the generated annotation (or earlier), however if the generated element is nested deeper in the annotation processing than the generated annotation, then it will be missed. For example: round 1 generated the annotation and the element, round 2 the generated annotation is detected and during its processing the generated element will be detected - this will work as desired. However, if the annotation is generated in round 1 and the element not until round 2 or later, then it will not be seen during processing.

## AnnotationLoaderProcessor
Unlike the other processors, this is not designed to generate anything, but rather act as a notifier when an annotation with a given annotation is detected. The goal is to notify when an annotation is generated, provided the annotation in question has an annotation applied to it. This is designed to work in conjunction with `AbstractDelayedAnnotationTendrilProcessor` to trigger any delayed processing resulting from a missing annotation. For example, the `<Enum>Id` annotations generated from `@BeanIdEnum` annotated `Enums` have an `@EnumQualifier` annotation applied. Thus, `tendril-di` has an `AnnotationLoaderProcessor` which looks for `@EnumQualifier` and notifies whenever it detects one. Client loaders do not need to do anything more than just simply extend `AnnotationLoaderProcessor` and configuring themselves to look for the annotation which is applied to the generated annotation (i.e.: `@EnumQualifier` per the example). Loaders are not expected to perform any actual processing.

## EnvironmentCollector
This is the only processor which is directly provided by the `tendril-annotation-processor` library, however it is not a processor per-say. It does no processing other than to track all elements which were detected for each round (or more accurately it listens for all annotations and save the `RoundEnvironment` for each round). This allows it to act as a repository of all processable elements, and can be leveraged by other processors (such as `AbstractGeneratedAnnotationTendrilProcessor`) to "rerun" processing on previous rounds, if previous round would have been skipped for some reason. This is not intended to be overridden in the client annotation processor, however it can be leveraged if/when needed by calling `EnvironmentCollector.getAllEnvironments()`.
